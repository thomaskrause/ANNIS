/*
 * Copyright 2016 SFB 632.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package annis.administration;

import com.google.common.base.Preconditions;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Objects;
import org.corpus_tools.salt.SaltFactory;
import org.corpus_tools.salt.common.SCorpus;
import org.corpus_tools.salt.common.SCorpusGraph;
import org.corpus_tools.salt.common.SDocument;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.SqlProvider;
import org.springframework.transaction.annotation.Transactional;

/**
 * A DAO to insert and delete documents to/from existing corpora in the database.
 * 
 * @author Thomas Krause <krauseto@hu-berlin.de>
 */
public class DocumentManagementDao extends AbstractAdminstrationDao
{
  /**
   * Deletes a document
   * @param toplevelCorpus
   * @param documentName 
   */
  @Transactional
  public void deleteDocument(String toplevelCorpus, String documentName)
  {
    Preconditions.checkNotNull(toplevelCorpus);
    Preconditions.checkNotNull(documentName);
    
    // get the current corpus graph from the database
    CorpusGraphMapper mapper = new CorpusGraphMapper(toplevelCorpus);
    SCorpusGraph corpusGraph = getJdbcTemplate().query(mapper.getSql(), mapper, mapper);
   
    SDocument docToRemove = null;
    for(SDocument doc : corpusGraph.getDocuments())
    {
      if(documentName.equals(doc.getName()))
      {
        docToRemove = doc;
        break;
      }
    }
    if(docToRemove != null)
    {
      // remove the document from our internal representation
      corpusGraph.removeNode(docToRemove);
      
      // TODO: write updated corpus graph in corpus table
      
      // TODO: delete from facts table
      // TODO: update node IDs etc
      
      
    }
  }
  
    /**
   * Appends a Salt document to an existing corpus.
   * @param toplevelCorpus The name of the toplevel corpus that this document should be appended to.
   * @param doc The document
   */
  @Transactional
  public void insertDocument(String toplevelCorpus, SDocument doc)
  {
    final ANNISFormatVersion version = ANNISFormatVersion.V3_3;
    
    // TODO: implement
    
//    createStagingAreaV33(temporaryStagingArea);
//    bulkImport(path, version);
//
//    String toplevelCorpusName = getTopLevelCorpusFromTmpArea();
//
//    applyConstraints();
//    createStagingAreaIndexes(version);
//
//    fixResolverVisMapTable(toplevelCorpusName, tableInStagingArea(
//      FILE_RESOLVER_VIS_MAP));
//    analyzeStagingTables();
//
//    addDocumentNameMetaData();
//
//    AdministrationDao.Offsets offsets = calculateOffsets();
//    long corpusID = getQueryDao().mapCorpusNameToId(toplevelCorpusName);
//    createNodeIdMapping();
//
//    importBinaryData(path, toplevelCorpusName);
//
//    extendStagingText(corpusID);
//    extendStagingExampleQueries(corpusID);
//
//    analyzeAutoGeneratedQueries(corpusID);
//
//    computeCorpusStatistics(path);
//
//    analyzeStagingTables();
//
//    insertCorpus(corpusID, offsets);
//
//    // TODO: re-calculate the pre/post order of the documents
//    computeCorpusPath(corpusID);
//
//    createAnnotations(corpusID);
//
//    createAnnoCategory(corpusID);
//
//    // create the new facts table partition
//    createFacts(corpusID, version, offsets);
//    
//    if(hackDistinctLeftRightToken)
//    {
//      adjustDistinctLeftRightToken(corpusID);
//    }
//    
//    if (temporaryStagingArea)
//    {
//      dropStagingArea();
//    }
//
//    // create empty corpus properties file
//    if (getQueryDao().getCorpusConfigurationSave(toplevelCorpusName) == null)
//    {
//      log.info("creating new corpus.properties file");
//      getQueryDao().setCorpusConfiguration(toplevelCorpusName, new Properties());
//    }
//
//    analyzeFacts(corpusID);
//    analyzeTextTable(toplevelCorpusName);
//    generateExampleQueries(corpusID);
//
//    if (aliasName != null && !aliasName.isEmpty())
//    {
//      addCorpusAlias(corpusID, aliasName);
//    }
//    return true; 
  }
  
  private static class CorpusGraphMapper implements ResultSetExtractor<SCorpusGraph>,
    SqlProvider, PreparedStatementSetter
  {
    
    private final String toplevelCorpusName;

    public CorpusGraphMapper(String toplevelCorpus)
    {
      this.toplevelCorpusName = toplevelCorpus;
    }

    
    
    @Override
    public SCorpusGraph extractData(ResultSet rs) throws SQLException, DataAccessException
    {
      SCorpusGraph cg = SaltFactory.createSCorpusGraph();
      
      Preconditions.checkState(rs.next());
      
      // the first row must always contain the toplevel corpus entry
      Boolean toplevel = rs.getBoolean("top_level");
      Preconditions.checkState(Objects.equals(toplevel, Boolean.TRUE));
      Preconditions.checkState(Objects.equals(rs.getString("name"), toplevelCorpusName));
      
      SCorpus topCorpus = cg.createCorpus(null, toplevelCorpusName);
      
      return cg;
    }

    @Override
    public String getSql()
    {
      return "SELECT sub.name, sub.type, sub.pre, sub.post, sub.top_level\n"
        + "FROM corpus AS top, corpus AS sub\n"
        + "WHERE top.name=? AND sub.pre >= top.pre AND sub.post <= top.post\n"
        + "ORDER BY sub.pre, sub.post";
    }

    @Override
    public void setValues(PreparedStatement ps) throws SQLException
    {
      ps.setString(1, toplevelCorpusName);
    }

  }
}
